{"version":3,"file":"PolygonGeometryLibrary-84bd401d.js","sources":["../../../../Source/Core/Queue.js","../../../../Source/Core/PolygonGeometryLibrary.js"],"sourcesContent":["/**\n * A queue that can enqueue items at the end, and dequeue items from the front.\n *\n * @alias Queue\n * @constructor\n */\nfunction Queue() {\n  this._array = [];\n  this._offset = 0;\n  this._length = 0;\n}\n\nObject.defineProperties(Queue.prototype, {\n  /**\n   * The length of the queue.\n   *\n   * @memberof Queue.prototype\n   *\n   * @type {Number}\n   * @readonly\n   */\n  length: {\n    get: function () {\n      return this._length;\n    },\n  },\n});\n\n/**\n * Enqueues the specified item.\n *\n * @param {*} item The item to enqueue.\n */\nQueue.prototype.enqueue = function (item) {\n  this._array.push(item);\n  this._length++;\n};\n\n/**\n * Dequeues an item.  Returns undefined if the queue is empty.\n *\n * @returns {*} The the dequeued item.\n */\nQueue.prototype.dequeue = function () {\n  if (this._length === 0) {\n    return undefined;\n  }\n\n  const array = this._array;\n  let offset = this._offset;\n  const item = array[offset];\n  array[offset] = undefined;\n\n  offset++;\n  if (offset > 10 && offset * 2 > array.length) {\n    //compact array\n    this._array = array.slice(offset);\n    offset = 0;\n  }\n\n  this._offset = offset;\n  this._length--;\n\n  return item;\n};\n\n/**\n * Returns the item at the front of the queue.  Returns undefined if the queue is empty.\n *\n * @returns {*} The item at the front of the queue.\n */\nQueue.prototype.peek = function () {\n  if (this._length === 0) {\n    return undefined;\n  }\n\n  return this._array[this._offset];\n};\n\n/**\n * Check whether this queue contains the specified item.\n *\n * @param {*} item The item to search for.\n */\nQueue.prototype.contains = function (item) {\n  return this._array.indexOf(item) !== -1;\n};\n\n/**\n * Remove all items from the queue.\n */\nQueue.prototype.clear = function () {\n  this._array.length = this._offset = this._length = 0;\n};\n\n/**\n * Sort the items in the queue in-place.\n *\n * @param {Queue.Comparator} compareFunction A function that defines the sort order.\n */\nQueue.prototype.sort = function (compareFunction) {\n  if (this._offset > 0) {\n    //compact array\n    this._array = this._array.slice(this._offset);\n    this._offset = 0;\n  }\n\n  this._array.sort(compareFunction);\n};\n\n/**\n * A function used to compare two items while sorting a queue.\n * @callback Queue.Comparator\n *\n * @param {*} a An item in the array.\n * @param {*} b An item in the array.\n * @returns {Number} Returns a negative value if <code>a</code> is less than <code>b</code>,\n *          a positive value if <code>a</code> is greater than <code>b</code>, or\n *          0 if <code>a</code> is equal to <code>b</code>.\n *\n * @example\n * function compareNumbers(a, b) {\n *     return a - b;\n * }\n */\nexport default Queue;\n","import ArcType from \"./ArcType.js\";\nimport arrayRemoveDuplicates from \"./arrayRemoveDuplicates.js\";\nimport Cartesian2 from \"./Cartesian2.js\";\nimport Cartesian3 from \"./Cartesian3.js\";\nimport Cartographic from \"./Cartographic.js\";\nimport ComponentDatatype from \"./ComponentDatatype.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport EllipsoidRhumbLine from \"./EllipsoidRhumbLine.js\";\nimport Geometry from \"./Geometry.js\";\nimport GeometryAttribute from \"./GeometryAttribute.js\";\nimport GeometryAttributes from \"./GeometryAttributes.js\";\nimport GeometryPipeline from \"./GeometryPipeline.js\";\nimport IndexDatatype from \"./IndexDatatype.js\";\nimport CesiumMath from \"./Math.js\";\nimport Matrix3 from \"./Matrix3.js\";\nimport PolygonPipeline from \"./PolygonPipeline.js\";\nimport PrimitiveType from \"./PrimitiveType.js\";\nimport Quaternion from \"./Quaternion.js\";\nimport Queue from \"./Queue.js\";\nimport WindingOrder from \"./WindingOrder.js\";\n\n/**\n * @private\n */\nconst PolygonGeometryLibrary = {};\n\nPolygonGeometryLibrary.computeHierarchyPackedLength = function (\n  polygonHierarchy,\n  CartesianX\n) {\n  let numComponents = 0;\n  const stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    const hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    numComponents += 2;\n\n    const positions = hierarchy.positions;\n    const holes = hierarchy.holes;\n\n    if (defined(positions) && positions.length > 0) {\n      numComponents += positions.length * CartesianX.packedLength;\n    }\n\n    if (defined(holes)) {\n      const length = holes.length;\n      for (let i = 0; i < length; ++i) {\n        stack.push(holes[i]);\n      }\n    }\n  }\n\n  return numComponents;\n};\n\nPolygonGeometryLibrary.packPolygonHierarchy = function (\n  polygonHierarchy,\n  array,\n  startingIndex,\n  CartesianX\n) {\n  const stack = [polygonHierarchy];\n  while (stack.length > 0) {\n    const hierarchy = stack.pop();\n    if (!defined(hierarchy)) {\n      continue;\n    }\n\n    const positions = hierarchy.positions;\n    const holes = hierarchy.holes;\n\n    array[startingIndex++] = defined(positions) ? positions.length : 0;\n    array[startingIndex++] = defined(holes) ? holes.length : 0;\n\n    if (defined(positions)) {\n      const positionsLength = positions.length;\n      for (\n        let i = 0;\n        i < positionsLength;\n        ++i, startingIndex += CartesianX.packedLength\n      ) {\n        CartesianX.pack(positions[i], array, startingIndex);\n      }\n    }\n\n    if (defined(holes)) {\n      const holesLength = holes.length;\n      for (let j = 0; j < holesLength; ++j) {\n        stack.push(holes[j]);\n      }\n    }\n  }\n\n  return startingIndex;\n};\n\nPolygonGeometryLibrary.unpackPolygonHierarchy = function (\n  array,\n  startingIndex,\n  CartesianX\n) {\n  const positionsLength = array[startingIndex++];\n  const holesLength = array[startingIndex++];\n\n  const positions = new Array(positionsLength);\n  const holes = holesLength > 0 ? new Array(holesLength) : undefined;\n\n  for (\n    let i = 0;\n    i < positionsLength;\n    ++i, startingIndex += CartesianX.packedLength\n  ) {\n    positions[i] = CartesianX.unpack(array, startingIndex);\n  }\n\n  for (let j = 0; j < holesLength; ++j) {\n    holes[j] = PolygonGeometryLibrary.unpackPolygonHierarchy(\n      array,\n      startingIndex,\n      CartesianX\n    );\n    startingIndex = holes[j].startingIndex;\n    delete holes[j].startingIndex;\n  }\n\n  return {\n    positions: positions,\n    holes: holes,\n    startingIndex: startingIndex,\n  };\n};\n\nconst distance2DScratch = new Cartesian2();\nfunction getPointAtDistance2D(p0, p1, distance, length) {\n  Cartesian2.subtract(p1, p0, distance2DScratch);\n  Cartesian2.multiplyByScalar(\n    distance2DScratch,\n    distance / length,\n    distance2DScratch\n  );\n  Cartesian2.add(p0, distance2DScratch, distance2DScratch);\n  return [distance2DScratch.x, distance2DScratch.y];\n}\n\nconst distanceScratch = new Cartesian3();\nfunction getPointAtDistance(p0, p1, distance, length) {\n  Cartesian3.subtract(p1, p0, distanceScratch);\n  Cartesian3.multiplyByScalar(\n    distanceScratch,\n    distance / length,\n    distanceScratch\n  );\n  Cartesian3.add(p0, distanceScratch, distanceScratch);\n  return [distanceScratch.x, distanceScratch.y, distanceScratch.z];\n}\n\nPolygonGeometryLibrary.subdivideLineCount = function (p0, p1, minDistance) {\n  const distance = Cartesian3.distance(p0, p1);\n  const n = distance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\nconst scratchCartographic0 = new Cartographic();\nconst scratchCartographic1 = new Cartographic();\nconst scratchCartographic2 = new Cartographic();\nconst scratchCartesian0 = new Cartesian3();\nconst scratchRhumbLine = new EllipsoidRhumbLine();\nPolygonGeometryLibrary.subdivideRhumbLineCount = function (\n  ellipsoid,\n  p0,\n  p1,\n  minDistance\n) {\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n  const n = rhumb.surfaceDistance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  return Math.pow(2, countDivide);\n};\n\n/**\n * Subdivides texture coordinates based on the subdivision of the associated world positions.\n *\n * @param {Cartesian2} t0 First texture coordinate.\n * @param {Cartesian2} t1 Second texture coordinate.\n * @param {Cartesian3} p0 First world position.\n * @param {Cartesian3} p1 Second world position.\n * @param {Number} minDistance Minimum distance for a segment.\n * @param {Array<Cartesian2>} result The subdivided texture coordinates.\n *\n * @private\n */\nPolygonGeometryLibrary.subdivideTexcoordLine = function (\n  t0,\n  t1,\n  p0,\n  p1,\n  minDistance,\n  result\n) {\n  // Compute the number of subdivisions.\n  const subdivisions = PolygonGeometryLibrary.subdivideLineCount(\n    p0,\n    p1,\n    minDistance\n  );\n\n  // Compute the distance between each subdivided point.\n  const length2D = Cartesian2.distance(t0, t1);\n  const distanceBetweenCoords = length2D / subdivisions;\n\n  // Resize the result array.\n  const texcoords = result;\n  texcoords.length = subdivisions * 2;\n\n  // Compute texture coordinates using linear interpolation.\n  let index = 0;\n  for (let i = 0; i < subdivisions; i++) {\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\n    texcoords[index++] = t[0];\n    texcoords[index++] = t[1];\n  }\n\n  return texcoords;\n};\n\nPolygonGeometryLibrary.subdivideLine = function (p0, p1, minDistance, result) {\n  const numVertices = PolygonGeometryLibrary.subdivideLineCount(\n    p0,\n    p1,\n    minDistance\n  );\n  const length = Cartesian3.distance(p0, p1);\n  const distanceBetweenVertices = length / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const positions = result;\n  positions.length = numVertices * 3;\n\n  let index = 0;\n  for (let i = 0; i < numVertices; i++) {\n    const p = getPointAtDistance(p0, p1, i * distanceBetweenVertices, length);\n    positions[index++] = p[0];\n    positions[index++] = p[1];\n    positions[index++] = p[2];\n  }\n\n  return positions;\n};\n\n/**\n * Subdivides texture coordinates based on the subdivision of the associated world positions using a rhumb line.\n *\n * @param {Cartesian2} t0 First texture coordinate.\n * @param {Cartesian2} t1 Second texture coordinate.\n * @param {Ellipsoid} ellipsoid The ellipsoid.\n * @param {Cartesian3} p0 First world position.\n * @param {Cartesian3} p1 Second world position.\n * @param {Number} minDistance Minimum distance for a segment.\n * @param {Array<Cartesian2>} result The subdivided texture coordinates.\n *\n * @private\n */\nPolygonGeometryLibrary.subdivideTexcoordRhumbLine = function (\n  t0,\n  t1,\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n  result\n) {\n  // Compute the surface distance.\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  scratchRhumbLine.setEndPoints(c0, c1);\n  const n = scratchRhumbLine.surfaceDistance / minDistance;\n\n  // Compute the number of subdivisions.\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  const subdivisions = Math.pow(2, countDivide);\n\n  // Compute the distance between each subdivided point.\n  const length2D = Cartesian2.distance(t0, t1);\n  const distanceBetweenCoords = length2D / subdivisions;\n\n  // Resize the result array.\n  const texcoords = result;\n  texcoords.length = subdivisions * 2;\n\n  // Compute texture coordinates using linear interpolation.\n  let index = 0;\n  for (let i = 0; i < subdivisions; i++) {\n    const t = getPointAtDistance2D(t0, t1, i * distanceBetweenCoords, length2D);\n    texcoords[index++] = t[0];\n    texcoords[index++] = t[1];\n  }\n\n  return texcoords;\n};\n\nPolygonGeometryLibrary.subdivideRhumbLine = function (\n  ellipsoid,\n  p0,\n  p1,\n  minDistance,\n  result\n) {\n  const c0 = ellipsoid.cartesianToCartographic(p0, scratchCartographic0);\n  const c1 = ellipsoid.cartesianToCartographic(p1, scratchCartographic1);\n  const rhumb = new EllipsoidRhumbLine(c0, c1, ellipsoid);\n\n  const n = rhumb.surfaceDistance / minDistance;\n  const countDivide = Math.max(0, Math.ceil(CesiumMath.log2(n)));\n  const numVertices = Math.pow(2, countDivide);\n  const distanceBetweenVertices = rhumb.surfaceDistance / numVertices;\n\n  if (!defined(result)) {\n    result = [];\n  }\n\n  const positions = result;\n  positions.length = numVertices * 3;\n\n  let index = 0;\n  for (let i = 0; i < numVertices; i++) {\n    const c = rhumb.interpolateUsingSurfaceDistance(\n      i * distanceBetweenVertices,\n      scratchCartographic2\n    );\n    const p = ellipsoid.cartographicToCartesian(c, scratchCartesian0);\n    positions[index++] = p.x;\n    positions[index++] = p.y;\n    positions[index++] = p.z;\n  }\n\n  return positions;\n};\n\nconst scaleToGeodeticHeightN1 = new Cartesian3();\nconst scaleToGeodeticHeightN2 = new Cartesian3();\nconst scaleToGeodeticHeightP1 = new Cartesian3();\nconst scaleToGeodeticHeightP2 = new Cartesian3();\n\nPolygonGeometryLibrary.scaleToGeodeticHeightExtruded = function (\n  geometry,\n  maxHeight,\n  minHeight,\n  ellipsoid,\n  perPositionHeight\n) {\n  ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\n\n  const n1 = scaleToGeodeticHeightN1;\n  let n2 = scaleToGeodeticHeightN2;\n  const p = scaleToGeodeticHeightP1;\n  let p2 = scaleToGeodeticHeightP2;\n\n  if (\n    defined(geometry) &&\n    defined(geometry.attributes) &&\n    defined(geometry.attributes.position)\n  ) {\n    const positions = geometry.attributes.position.values;\n    const length = positions.length / 2;\n\n    for (let i = 0; i < length; i += 3) {\n      Cartesian3.fromArray(positions, i, p);\n\n      ellipsoid.geodeticSurfaceNormal(p, n1);\n      p2 = ellipsoid.scaleToGeodeticSurface(p, p2);\n      n2 = Cartesian3.multiplyByScalar(n1, minHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i + length] = n2.x;\n      positions[i + 1 + length] = n2.y;\n      positions[i + 2 + length] = n2.z;\n\n      if (perPositionHeight) {\n        p2 = Cartesian3.clone(p, p2);\n      }\n      n2 = Cartesian3.multiplyByScalar(n1, maxHeight, n2);\n      n2 = Cartesian3.add(p2, n2, n2);\n      positions[i] = n2.x;\n      positions[i + 1] = n2.y;\n      positions[i + 2] = n2.z;\n    }\n  }\n  return geometry;\n};\n\nPolygonGeometryLibrary.polygonOutlinesFromHierarchy = function (\n  polygonHierarchy,\n  scaleToEllipsoidSurface,\n  ellipsoid\n) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  const polygons = [];\n  const queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n  let i;\n  let j;\n  let length;\n  while (queue.length !== 0) {\n    const outerNode = queue.dequeue();\n    let outerRing = outerNode.positions;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n    outerRing = arrayRemoveDuplicates(\n      outerRing,\n      Cartesian3.equalsEpsilon,\n      true\n    );\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    const numChildren = outerNode.holes ? outerNode.holes.length : 0;\n    // The outer polygon contains inner polygons\n    for (i = 0; i < numChildren; i++) {\n      const hole = outerNode.holes[i];\n      let holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n      holePositions = arrayRemoveDuplicates(\n        holePositions,\n        Cartesian3.equalsEpsilon,\n        true\n      );\n      if (holePositions.length < 3) {\n        continue;\n      }\n      polygons.push(holePositions);\n\n      let numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    polygons.push(outerRing);\n  }\n\n  return polygons;\n};\n\nPolygonGeometryLibrary.polygonsFromHierarchy = function (\n  polygonHierarchy,\n  keepDuplicates,\n  projectPointsTo2D,\n  scaleToEllipsoidSurface,\n  ellipsoid\n) {\n  // create from a polygon hierarchy\n  // Algorithm adapted from http://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n  const hierarchy = [];\n  const polygons = [];\n\n  const queue = new Queue();\n  queue.enqueue(polygonHierarchy);\n\n  while (queue.length !== 0) {\n    const outerNode = queue.dequeue();\n    let outerRing = outerNode.positions;\n    const holes = outerNode.holes;\n\n    let i;\n    let length;\n    if (scaleToEllipsoidSurface) {\n      length = outerRing.length;\n      for (i = 0; i < length; i++) {\n        ellipsoid.scaleToGeodeticSurface(outerRing[i], outerRing[i]);\n      }\n    }\n\n    if (!keepDuplicates) {\n      outerRing = arrayRemoveDuplicates(\n        outerRing,\n        Cartesian3.equalsEpsilon,\n        true\n      );\n    }\n    if (outerRing.length < 3) {\n      continue;\n    }\n\n    let positions2D = projectPointsTo2D(outerRing);\n    if (!defined(positions2D)) {\n      continue;\n    }\n    const holeIndices = [];\n\n    let originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\n      positions2D\n    );\n    if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n      positions2D.reverse();\n      outerRing = outerRing.slice().reverse();\n    }\n\n    let positions = outerRing.slice();\n    const numChildren = defined(holes) ? holes.length : 0;\n    const polygonHoles = [];\n    let j;\n\n    for (i = 0; i < numChildren; i++) {\n      const hole = holes[i];\n      let holePositions = hole.positions;\n      if (scaleToEllipsoidSurface) {\n        length = holePositions.length;\n        for (j = 0; j < length; ++j) {\n          ellipsoid.scaleToGeodeticSurface(holePositions[j], holePositions[j]);\n        }\n      }\n\n      if (!keepDuplicates) {\n        holePositions = arrayRemoveDuplicates(\n          holePositions,\n          Cartesian3.equalsEpsilon,\n          true\n        );\n      }\n      if (holePositions.length < 3) {\n        continue;\n      }\n\n      const holePositions2D = projectPointsTo2D(holePositions);\n      if (!defined(holePositions2D)) {\n        continue;\n      }\n\n      originalWindingOrder = PolygonPipeline.computeWindingOrder2D(\n        holePositions2D\n      );\n      if (originalWindingOrder === WindingOrder.CLOCKWISE) {\n        holePositions2D.reverse();\n        holePositions = holePositions.slice().reverse();\n      }\n\n      polygonHoles.push(holePositions);\n      holeIndices.push(positions.length);\n      positions = positions.concat(holePositions);\n      positions2D = positions2D.concat(holePositions2D);\n\n      let numGrandchildren = 0;\n      if (defined(hole.holes)) {\n        numGrandchildren = hole.holes.length;\n      }\n\n      for (j = 0; j < numGrandchildren; j++) {\n        queue.enqueue(hole.holes[j]);\n      }\n    }\n\n    hierarchy.push({\n      outerRing: outerRing,\n      holes: polygonHoles,\n    });\n    polygons.push({\n      positions: positions,\n      positions2D: positions2D,\n      holes: holeIndices,\n    });\n  }\n\n  return {\n    hierarchy: hierarchy,\n    polygons: polygons,\n  };\n};\n\nconst computeBoundingRectangleCartesian2 = new Cartesian2();\nconst computeBoundingRectangleCartesian3 = new Cartesian3();\nconst computeBoundingRectangleQuaternion = new Quaternion();\nconst computeBoundingRectangleMatrix3 = new Matrix3();\nPolygonGeometryLibrary.computeBoundingRectangle = function (\n  planeNormal,\n  projectPointTo2D,\n  positions,\n  angle,\n  result\n) {\n  const rotation = Quaternion.fromAxisAngle(\n    planeNormal,\n    angle,\n    computeBoundingRectangleQuaternion\n  );\n  const textureMatrix = Matrix3.fromQuaternion(\n    rotation,\n    computeBoundingRectangleMatrix3\n  );\n\n  let minX = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n\n  const length = positions.length;\n  for (let i = 0; i < length; ++i) {\n    const p = Cartesian3.clone(\n      positions[i],\n      computeBoundingRectangleCartesian3\n    );\n    Matrix3.multiplyByVector(textureMatrix, p, p);\n    const st = projectPointTo2D(p, computeBoundingRectangleCartesian2);\n\n    if (defined(st)) {\n      minX = Math.min(minX, st.x);\n      maxX = Math.max(maxX, st.x);\n\n      minY = Math.min(minY, st.y);\n      maxY = Math.max(maxY, st.y);\n    }\n  }\n\n  result.x = minX;\n  result.y = minY;\n  result.width = maxX - minX;\n  result.height = maxY - minY;\n  return result;\n};\n\nPolygonGeometryLibrary.createGeometryFromPositions = function (\n  ellipsoid,\n  polygon,\n  textureCoordinates,\n  granularity,\n  perPositionHeight,\n  vertexFormat,\n  arcType\n) {\n  let indices = PolygonPipeline.triangulate(polygon.positions2D, polygon.holes);\n\n  /* If polygon is completely unrenderable, just use the first three vertices */\n  if (indices.length < 3) {\n    indices = [0, 1, 2];\n  }\n\n  const positions = polygon.positions;\n\n  const hasTexcoords = defined(textureCoordinates);\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\n\n  if (perPositionHeight) {\n    const length = positions.length;\n    const flattenedPositions = new Array(length * 3);\n    let index = 0;\n    for (let i = 0; i < length; i++) {\n      const p = positions[i];\n      flattenedPositions[index++] = p.x;\n      flattenedPositions[index++] = p.y;\n      flattenedPositions[index++] = p.z;\n    }\n\n    const geometryOptions = {\n      attributes: {\n        position: new GeometryAttribute({\n          componentDatatype: ComponentDatatype.DOUBLE,\n          componentsPerAttribute: 3,\n          values: flattenedPositions,\n        }),\n      },\n      indices: indices,\n      primitiveType: PrimitiveType.TRIANGLES,\n    };\n\n    if (hasTexcoords) {\n      geometryOptions.attributes.st = new GeometryAttribute({\n        componentDatatype: ComponentDatatype.FLOAT,\n        componentsPerAttribute: 2,\n        values: Cartesian2.packArray(texcoords),\n      });\n    }\n\n    const geometry = new Geometry(geometryOptions);\n\n    if (vertexFormat.normal) {\n      return GeometryPipeline.computeNormal(geometry);\n    }\n\n    return geometry;\n  }\n\n  if (arcType === ArcType.GEODESIC) {\n    return PolygonPipeline.computeSubdivision(\n      ellipsoid,\n      positions,\n      indices,\n      texcoords,\n      granularity\n    );\n  } else if (arcType === ArcType.RHUMB) {\n    return PolygonPipeline.computeRhumbLineSubdivision(\n      ellipsoid,\n      positions,\n      indices,\n      texcoords,\n      granularity\n    );\n  }\n};\n\nconst computeWallTexcoordsSubdivided = [];\nconst computeWallIndicesSubdivided = [];\nconst p1Scratch = new Cartesian3();\nconst p2Scratch = new Cartesian3();\n\nPolygonGeometryLibrary.computeWallGeometry = function (\n  positions,\n  textureCoordinates,\n  ellipsoid,\n  granularity,\n  perPositionHeight,\n  arcType\n) {\n  let edgePositions;\n  let topEdgeLength;\n  let i;\n  let p1;\n  let p2;\n  let t1;\n  let t2;\n  let edgeTexcoords;\n  let topEdgeTexcoordLength;\n\n  let length = positions.length;\n  let index = 0;\n  let textureIndex = 0;\n\n  const hasTexcoords = defined(textureCoordinates);\n  const texcoords = hasTexcoords ? textureCoordinates.positions : undefined;\n\n  if (!perPositionHeight) {\n    const minDistance = CesiumMath.chordLength(\n      granularity,\n      ellipsoid.maximumRadius\n    );\n\n    let numVertices = 0;\n    if (arcType === ArcType.GEODESIC) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideLineCount(\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    } else if (arcType === ArcType.RHUMB) {\n      for (i = 0; i < length; i++) {\n        numVertices += PolygonGeometryLibrary.subdivideRhumbLineCount(\n          ellipsoid,\n          positions[i],\n          positions[(i + 1) % length],\n          minDistance\n        );\n      }\n    }\n\n    topEdgeLength = (numVertices + length) * 3;\n    edgePositions = new Array(topEdgeLength * 2);\n\n    if (hasTexcoords) {\n      topEdgeTexcoordLength = (numVertices + length) * 2;\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\n    }\n\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n\n      let tempPositions;\n      let tempTexcoords;\n\n      if (hasTexcoords) {\n        t1 = texcoords[i];\n        t2 = texcoords[(i + 1) % length];\n      }\n\n      if (arcType === ArcType.GEODESIC) {\n        tempPositions = PolygonGeometryLibrary.subdivideLine(\n          p1,\n          p2,\n          minDistance,\n          computeWallIndicesSubdivided\n        );\n        if (hasTexcoords) {\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordLine(\n            t1,\n            t2,\n            p1,\n            p2,\n            minDistance,\n            computeWallTexcoordsSubdivided\n          );\n        }\n      } else if (arcType === ArcType.RHUMB) {\n        tempPositions = PolygonGeometryLibrary.subdivideRhumbLine(\n          ellipsoid,\n          p1,\n          p2,\n          minDistance,\n          computeWallIndicesSubdivided\n        );\n        if (hasTexcoords) {\n          tempTexcoords = PolygonGeometryLibrary.subdivideTexcoordRhumbLine(\n            t1,\n            t2,\n            ellipsoid,\n            p1,\n            p2,\n            minDistance,\n            computeWallTexcoordsSubdivided\n          );\n        }\n      }\n      const tempPositionsLength = tempPositions.length;\n      for (let j = 0; j < tempPositionsLength; ++j, ++index) {\n        edgePositions[index] = tempPositions[j];\n        edgePositions[index + topEdgeLength] = tempPositions[j];\n      }\n\n      edgePositions[index] = p2.x;\n      edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n\n      edgePositions[index] = p2.y;\n      edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n\n      edgePositions[index] = p2.z;\n      edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n\n      if (hasTexcoords) {\n        const tempTexcoordsLength = tempTexcoords.length;\n        for (let k = 0; k < tempTexcoordsLength; ++k, ++textureIndex) {\n          edgeTexcoords[textureIndex] = tempTexcoords[k];\n          edgeTexcoords[textureIndex + topEdgeTexcoordLength] =\n            tempTexcoords[k];\n        }\n\n        edgeTexcoords[textureIndex] = t2.x;\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.x;\n        ++textureIndex;\n\n        edgeTexcoords[textureIndex] = t2.y;\n        edgeTexcoords[textureIndex + topEdgeTexcoordLength] = t2.y;\n        ++textureIndex;\n      }\n    }\n  } else {\n    topEdgeLength = length * 3 * 2;\n    edgePositions = new Array(topEdgeLength * 2);\n\n    if (hasTexcoords) {\n      topEdgeTexcoordLength = length * 2 * 2;\n      edgeTexcoords = new Array(topEdgeTexcoordLength * 2);\n    }\n\n    for (i = 0; i < length; i++) {\n      p1 = positions[i];\n      p2 = positions[(i + 1) % length];\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p1.z;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.x;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.y;\n      ++index;\n      edgePositions[index] = edgePositions[index + topEdgeLength] = p2.z;\n      ++index;\n\n      if (hasTexcoords) {\n        t1 = texcoords[i];\n        t2 = texcoords[(i + 1) % length];\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t1.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t1.y;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t2.x;\n        ++textureIndex;\n        edgeTexcoords[textureIndex] = edgeTexcoords[\n          textureIndex + topEdgeTexcoordLength\n        ] = t2.y;\n        ++textureIndex;\n      }\n    }\n  }\n\n  length = edgePositions.length;\n  const indices = IndexDatatype.createTypedArray(\n    length / 3,\n    length - positions.length * 6\n  );\n  let edgeIndex = 0;\n  length /= 6;\n\n  for (i = 0; i < length; i++) {\n    const UL = i;\n    const UR = UL + 1;\n    const LL = UL + length;\n    const LR = LL + 1;\n\n    p1 = Cartesian3.fromArray(edgePositions, UL * 3, p1Scratch);\n    p2 = Cartesian3.fromArray(edgePositions, UR * 3, p2Scratch);\n    if (\n      Cartesian3.equalsEpsilon(\n        p1,\n        p2,\n        CesiumMath.EPSILON10,\n        CesiumMath.EPSILON10\n      )\n    ) {\n      //skip corner\n      continue;\n    }\n\n    indices[edgeIndex++] = UL;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = UR;\n    indices[edgeIndex++] = LL;\n    indices[edgeIndex++] = LR;\n  }\n\n  const geometryOptions = {\n    attributes: new GeometryAttributes({\n      position: new GeometryAttribute({\n        componentDatatype: ComponentDatatype.DOUBLE,\n        componentsPerAttribute: 3,\n        values: edgePositions,\n      }),\n    }),\n    indices: indices,\n    primitiveType: PrimitiveType.TRIANGLES,\n  };\n\n  if (hasTexcoords) {\n    geometryOptions.attributes.st = new GeometryAttribute({\n      componentDatatype: ComponentDatatype.FLOAT,\n      componentsPerAttribute: 2,\n      values: edgeTexcoords,\n    });\n  }\n\n  const geometry = new Geometry(geometryOptions);\n\n  return geometry;\n};\nexport default PolygonGeometryLibrary;\n"],"names":["Queue","this","_array","_offset","_length","Object","defineProperties","prototype","length","get","enqueue","item","push","dequeue","array","offset","undefined","slice","peek","contains","indexOf","clear","sort","compareFunction","PolygonGeometryLibrary","polygonHierarchy","CartesianX","numComponents","stack","hierarchy","pop","defined","positions","holes","packedLength","i","startingIndex","positionsLength","pack","holesLength","j","Array","unpack","unpackPolygonHierarchy","distance2DScratch","Cartesian2","getPointAtDistance2D","p0","p1","distance","subtract","multiplyByScalar","add","x","y","distanceScratch","Cartesian3","getPointAtDistance","z","subdivideLineCount","minDistance","n","countDivide","Math","max","ceil","CesiumMath","log2","pow","scratchCartographic0","Cartographic","scratchCartographic1","scratchCartographic2","scratchCartesian0","scratchRhumbLine","EllipsoidRhumbLine","subdivideRhumbLineCount","ellipsoid","c0","cartesianToCartographic","c1","surfaceDistance","subdivideTexcoordLine","t0","t1","result","subdivisions","length2D","distanceBetweenCoords","texcoords","index","t","subdivideLine","numVertices","distanceBetweenVertices","p","subdivideTexcoordRhumbLine","setEndPoints","subdivideRhumbLine","rhumb","c","interpolateUsingSurfaceDistance","cartographicToCartesian","scaleToGeodeticHeightN1","scaleToGeodeticHeightN2","scaleToGeodeticHeightP1","scaleToGeodeticHeightP2","scaleToGeodeticHeightExtruded","geometry","maxHeight","minHeight","perPositionHeight","defaultValue","Ellipsoid","WGS84","n1","n2","p2","attributes","position","values","fromArray","geodeticSurfaceNormal","scaleToGeodeticSurface","clone","polygonOutlinesFromHierarchy","scaleToEllipsoidSurface","polygons","queue","outerNode","outerRing","arrayRemoveDuplicates","equalsEpsilon","numChildren","hole","holePositions","numGrandchildren","polygonsFromHierarchy","keepDuplicates","projectPointsTo2D","positions2D","holeIndices","originalWindingOrder","PolygonPipeline","computeWindingOrder2D","WindingOrder","CLOCKWISE","reverse","polygonHoles","holePositions2D","concat","computeBoundingRectangleCartesian2","computeBoundingRectangleCartesian3","computeBoundingRectangleQuaternion","Quaternion","computeBoundingRectangleMatrix3","Matrix3","computeBoundingRectangle","planeNormal","projectPointTo2D","angle","rotation","fromAxisAngle","textureMatrix","fromQuaternion","minX","Number","POSITIVE_INFINITY","maxX","NEGATIVE_INFINITY","minY","maxY","multiplyByVector","st","min","width","height","createGeometryFromPositions","polygon","textureCoordinates","granularity","vertexFormat","arcType","indices","triangulate","hasTexcoords","flattenedPositions","geometryOptions","GeometryAttribute","componentDatatype","ComponentDatatype","DOUBLE","componentsPerAttribute","primitiveType","PrimitiveType","TRIANGLES","FLOAT","packArray","Geometry","normal","GeometryPipeline","computeNormal","ArcType","GEODESIC","computeSubdivision","RHUMB","computeRhumbLineSubdivision","computeWallTexcoordsSubdivided","computeWallIndicesSubdivided","p1Scratch","p2Scratch","computeWallGeometry","edgePositions","topEdgeLength","t2","edgeTexcoords","topEdgeTexcoordLength","textureIndex","chordLength","maximumRadius","tempPositions","tempTexcoords","tempPositionsLength","tempTexcoordsLength","k","IndexDatatype","createTypedArray","edgeIndex","UL","UR","LL","LR","EPSILON10","GeometryAttributes"],"mappings":"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"}